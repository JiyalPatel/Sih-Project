const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs').promises;

const Batch = require('../models/batch.model');
const Subject = require('../models/subject.model');
const Faculty = require('../models/faculty.model');
const Room = require('../models/room.model');
const Timetable = require('../models/timetable.model');
const TimeSlot = require('../models/timeslot.model');

// Define the path to your Python scheduler script
const PYTHON_SCRIPT_PATH = path.join(__dirname, '..', 'app', 'v2', 'main.py');
const DATA_DIR = path.join(__dirname, '..', 'app', 'v2', 'data');

const runPythonScheduler = (data) => {
    return new Promise((resolve, reject) => {
        const pythonProcess = spawn('python', [PYTHON_SCRIPT_PATH]);
        let output = '';
        let error = '';

        pythonProcess.stdout.on('data', (data) => {
            output += data.toString();
        });

        pythonProcess.stderr.on('data', (data) => {
            error += data.toString();
        });

        pythonProcess.on('close', (code) => {
            if (code !== 0) {
                return reject(new Error(`Python script exited with code ${code}: ${error}`));
            }
            resolve(output);
        });

        pythonProcess.stdin.write(JSON.stringify(data));
        pythonProcess.stdin.end();
    });
};

const fetchDataAndRunScheduler = async (constraints) => {
    try {
        // Fetch all necessary data from MongoDB
        const batches = await Batch.find().populate('subjects');
        const subjects = await Subject.find().populate('faculty');
        const faculty = await Faculty.find().populate('subjects');
        const classrooms = await Room.find();

        // Prepare data for the Python script by writing to JSON files
        await fs.writeFile(path.join(DATA_DIR, 'batches.json'), JSON.stringify(batches, null, 2));
        await fs.writeFile(path.join(DATA_DIR, 'subjects.json'), JSON.stringify(subjects, null, 2));
        await fs.writeFile(path.join(DATA_DIR, 'faculty.json'), JSON.stringify(faculty, null, 2));
        await fs.writeFile(path.join(DATA_DIR, 'classrooms.json'), JSON.stringify(classrooms, null, 2));
        await fs.writeFile(path.join(DATA_DIR, 'timetable_constraints.json'), JSON.stringify(constraints, null, 2));

        // Execute Python script
        const pythonOutput = await runPythonScheduler({});

        // Read the output JSON files generated by the Python script
        const generatedTimetableRaw = await fs.readFile(path.join(DATA_DIR, 'output', 'timetable_top_1.json'), 'utf-8');
        const generatedTimetable = JSON.parse(generatedTimetableRaw);

        // Process the output and save to MongoDB
        const newTimetable = new Timetable({
            batch: generatedTimetable.schedule.batch_id,
            generatedBy: 'scheduler', // You can replace this with the user ID later
            slots: [],
        });

        for (const slotData of generatedTimetable.schedule) {
            const timeSlot = new TimeSlot({
                batch: slotData.batch,
                subject: slotData.subject,
                faculty: slotData.faculty,
                room: slotData.room,
                day: slotData.day,
                slot: slotData.slot,
            });
            await timeSlot.save();
            newTimetable.slots.push(timeSlot._id);
        }

        await newTimetable.save();
        return newTimetable;
    } catch (error) {
        console.error('Error in scheduler utility:', error);
        throw error;
    }
};

module.exports = {
    fetchDataAndRunScheduler,
};